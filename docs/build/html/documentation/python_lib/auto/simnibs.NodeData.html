
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>simnibs.NodeData &#8212; SimNIBS 3.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="simnibs.ElementData" href="simnibs.ElementData.html" />
    <link rel="prev" title="simnibs.Elements" href="simnibs.Elements.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="simnibs.Elements.html" title="Previous document">simnibs.Elements</a>
        </li>
        <li>
          <a href="simnibs.ElementData.html" title="Next document">simnibs.ElementData</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <div class="section" id="simnibs-nodedata">
<h1>simnibs.NodeData<a class="headerlink" href="#simnibs-nodedata" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="simnibs.NodeData">
<em class="property">class </em><code class="sig-prename descclassname">simnibs.</code><code class="sig-name descname">NodeData</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">name=''</em>, <em class="sig-param">mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">simnibs.msh.mesh_io.Data</span></code></p>
<p>Data (scalar, vector or tensor) defined in mesh nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>value</strong> (<em>ndarray</em>) – <dl class="simple">
<dt>Value of field in nodes. Should have the shape</dt><dd><ul>
<li><p>(n_nodes,) or (n_nodes, 1) for scalar fields</p></li>
<li><p>(n_nodes, 3) for vector fields</p></li>
<li><p>(n_nodes, 9) for tensors</p></li>
</ul>
</dd>
</dl>
</p></li>
<li><p><strong>field_name</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – name of field. Default: ‘’</p></li>
<li><p><strong>mesh</strong> (<em>simnibs.msh.Msh</em><em> (</em><em>optinal</em><em>)</em>) – Mesh where the field is defined. Required for many methods</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="simnibs.NodeData.value">
<code class="sig-name descname">value</code><a class="headerlink" href="#simnibs.NodeData.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Value of field in elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.NodeData.field_name">
<code class="sig-name descname">field_name</code><a class="headerlink" href="#simnibs.NodeData.field_name" title="Permalink to this definition">¶</a></dt>
<dd><p>name of field</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.NodeData.node_number">
<code class="sig-name descname">node_number</code><a class="headerlink" href="#simnibs.NodeData.node_number" title="Permalink to this definition">¶</a></dt>
<dd><p>index of elements</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.NodeData.nr">
<code class="sig-name descname">nr</code><a class="headerlink" href="#simnibs.NodeData.nr" title="Permalink to this definition">¶</a></dt>
<dd><p>number of data points</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>property</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="simnibs.NodeData.nr_comp">
<code class="sig-name descname">nr_comp</code><a class="headerlink" href="#simnibs.NodeData.nr_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>number of dimensions per data point (1 for scalars, 3 for vectors)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>property</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.__init__">
<code class="sig-name descname">__init__</code><span class="sig-paren">(</span><em class="sig-param">value</em>, <em class="sig-param">name=''</em>, <em class="sig-param">mesh=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.__init__" title="simnibs.NodeData.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(value[, name, mesh])</p></td>
<td><p>Initialize self.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.angle" title="simnibs.NodeData.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>([fill])</p></td>
<td><p>Calculate the angle between the field and the surface normal</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.append_to_mesh" title="simnibs.NodeData.append_to_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append_to_mesh</span></code></a>(fn[, mode])</p></td>
<td><p>Appends this NodeData fields to a file</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.as_nodedata" title="simnibs.NodeData.as_nodedata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_nodedata</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.calc_flux" title="simnibs.NodeData.calc_flux"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calc_flux</span></code></a>([nodes])</p></td>
<td><p>Calculates the flux of a vector field though the given nodes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.get_focality" title="simnibs.NodeData.get_focality"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_focality</span></code></a>([cuttofs, peak_percentile])</p></td>
<td><p>Caluclates field focality as the area/volume of the mesh experiencing a field norm of above (cut_off% of the field peak).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.get_percentiles" title="simnibs.NodeData.get_percentiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_percentiles</span></code></a>([percentile, roi])</p></td>
<td><p>Get percentiles of field (or field norm, if a vector field)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.gradient" title="simnibs.NodeData.gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gradient</span></code></a>()</p></td>
<td><p>Calculates the gradient of a field in the middle of the tetrahedra</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.interpolate_scattered" title="simnibs.NodeData.interpolate_scattered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_scattered</span></code></a>(points[, out_fill, …])</p></td>
<td><p>Interpolates the NodeaData into the points by finding the element containing the point and performing linear interpolation inside the element</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.interpolate_to_grid" title="simnibs.NodeData.interpolate_to_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_grid</span></code></a>(n_voxels, affine, **kwargs)</p></td>
<td><p>Interpolates the NodeData into a grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.interpolate_to_surface" title="simnibs.NodeData.interpolate_to_surface"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate_to_surface</span></code></a>(surface[, out_fill])</p></td>
<td><p>Interpolates the field in the nodes of a given surface The interpolation occurs in the tetrahedra!</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.mean_field_norm" title="simnibs.NodeData.mean_field_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean_field_norm</span></code></a>()</p></td>
<td><p>Calculates V*w/sum(w) Where V is the norm of the field, and w is the volume or area of the mesh where the field is defined.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.node_data2elm_data" title="simnibs.NodeData.node_data2elm_data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_data2elm_data</span></code></a>()</p></td>
<td><p>Transforms an ElementData field into a NodeData field the value in the element is the average of the value in the nodes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.norm" title="simnibs.NodeData.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>([ord])</p></td>
<td><p>Calculate the norm of the field</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.normal" title="simnibs.NodeData.normal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normal</span></code></a>([fill])</p></td>
<td><p>Calculate the normal component of the field in the mesh surfaces</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.read_hdf5_data_matrix_row" title="simnibs.NodeData.read_hdf5_data_matrix_row"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_hdf5_data_matrix_row</span></code></a>(leadfield_fn, …)</p></td>
<td><p>Reads a row of an hdf5 data matrix and store it as Data</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.summary" title="simnibs.NodeData.summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">summary</span></code></a>([percentiles, focality_cutoffs, units])</p></td>
<td><p>Creates a text summaty of the field</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.tangent" title="simnibs.NodeData.tangent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tangent</span></code></a>([fill])</p></td>
<td><p>Calculate the tangent component of the field in the surfaces</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.to_deformed_grid" title="simnibs.NodeData.to_deformed_grid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_deformed_grid</span></code></a>(warp, reference[, out, …])</p></td>
<td><p>Interpolates field to a grid and apply non-linear interpolation</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.to_nifti" title="simnibs.NodeData.to_nifti"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_nifti</span></code></a>(n_voxels, affine[, fn, units, …])</p></td>
<td><p>Transforms the data in a nifti file</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.view_options" title="simnibs.NodeData.view_options"><code class="xref py py-obj docutils literal notranslate"><span class="pre">view_options</span></code></a>([v_range, percentile, visible, …])</p></td>
<td><p>Generates a View object with visualization opions</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.write" title="simnibs.NodeData.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(fn)</p></td>
<td><p>Writes this NodeData field to a file with field information only This file needs to be merged with a mesh for visualization</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.write_hdf5" title="simnibs.NodeData.write_hdf5"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write_hdf5</span></code></a>(hdf5_fn[, path])</p></td>
<td><p>Writes the field to an hdf5 file</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.indexing_nr" title="simnibs.NodeData.indexing_nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">indexing_nr</span></code></a></p></td>
<td><p>Same as node_numbers</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.node_number" title="simnibs.NodeData.node_number"><code class="xref py py-obj docutils literal notranslate"><span class="pre">node_number</span></code></a></p></td>
<td><p>Node numbers (1, …, nr)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.nr" title="simnibs.NodeData.nr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr</span></code></a></p></td>
<td><p>Number of data entries</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#simnibs.NodeData.nr_comp" title="simnibs.NodeData.nr_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nr_comp</span></code></a></p></td>
<td><p>Number of field components</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#simnibs.NodeData.type" title="simnibs.NodeData.type"><code class="xref py py-obj docutils literal notranslate"><span class="pre">type</span></code></a></p></td>
<td><p>NodeData of ElementData</p></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="simnibs.NodeData.angle">
<code class="sig-name descname">angle</code><span class="sig-paren">(</span><em class="sig-param">fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the angle between the field and the surface normal</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>angle</strong> – NodeData field with the angles the field where a surface is defined and the
fill value where it’s not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.append_to_mesh">
<code class="sig-name descname">append_to_mesh</code><span class="sig-paren">(</span><em class="sig-param">fn</em>, <em class="sig-param">mode='binary'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.append_to_mesh" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends this NodeData fields to a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fn</strong> (<em>str</em>) – file name</p></li>
<li><p><strong>mode</strong> (<em>binary</em><em> or </em><em>ascii</em>) – mode in which to write</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.as_nodedata">
<code class="sig-name descname">as_nodedata</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.as_nodedata" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.calc_flux">
<code class="sig-name descname">calc_flux</code><span class="sig-paren">(</span><em class="sig-param">nodes=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.calc_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the flux of a vector field though the given nodes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nodes</strong> (<em>list of ints</em>) – List of node indices where to calculate flux. Default: all nodes in triangle
surface</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>flux</strong> – Total fux through all surfcaces</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.get_focality">
<code class="sig-name descname">get_focality</code><span class="sig-paren">(</span><em class="sig-param">cuttofs=[50, 70], peak_percentile=99.9</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.get_focality" title="Permalink to this definition">¶</a></dt>
<dd><p>Caluclates field focality as the area/volume of the mesh experiencing a field
norm of above (cut_off% of the field peak). peak_percentile gives what is the
field peak</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cuttofs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentage of the peak value for the cut_off, between 0 and 100. Default: [50, 70]</p></li>
<li><p><strong>peak_percentile</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Percentile to be used to calculate peak value. Default: 99.9</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>focality</strong> – Area/volume exceeding the cuttof of the peak value</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.get_percentiles">
<code class="sig-name descname">get_percentiles</code><span class="sig-paren">(</span><em class="sig-param">percentile=[99.9], roi=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.get_percentiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Get percentiles of field (or field norm, if a vector field)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percentile</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Percentiles of interest, between 0 and 100. Defaut: 99.9</p></li>
<li><p><strong>roi</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Region of interest in terms of element/node indices. Default: the whole mesh</p></li>
<li><p><strong>Returnts</strong> – </p></li>
<li><p><strong>----------</strong> – </p></li>
<li><p><strong>f_p</strong> (<em>ndarray</em>) – Field at the given percentiles</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.gradient">
<code class="sig-name descname">gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the gradient of a field in the middle of the tetrahedra</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mesh</strong> (<a class="reference internal" href="simnibs.Msh.html#simnibs.Msh" title="simnibs.Msh"><em>simnibs.Msh</em></a>) – A mesh with the geometrical information</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>grad</strong> – An ElementData field with gradient in the middle of each tetrahedra</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="simnibs.ElementData.html#simnibs.ElementData" title="simnibs.ElementData">simnibs.ElementData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.indexing_nr">
<em class="property">property </em><code class="sig-name descname">indexing_nr</code><a class="headerlink" href="#simnibs.NodeData.indexing_nr" title="Permalink to this definition">¶</a></dt>
<dd><p>Same as node_numbers</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.interpolate_scattered">
<code class="sig-name descname">interpolate_scattered</code><span class="sig-paren">(</span><em class="sig-param">points</em>, <em class="sig-param">out_fill=nan</em>, <em class="sig-param">squeeze=True</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.interpolate_scattered" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the NodeaData into the points by finding the element
containing the point and performing linear interpolation inside the element</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>points</strong> (<em>Nx3 ndarray</em>) – List of points where we want to interpolate</p></li>
<li><p><strong>out_fill</strong> (<em>float</em>) – Value to be goven to points outside the volume. If ‘nearest’, will assign the
value of th nearest node. (default: NaN)</p></li>
<li><p><strong>squeeze</strong> (<em>bool</em>) – Wether to squeeze the output. Default: True</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>f</strong> – Value of function in the points</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.interpolate_to_grid">
<code class="sig-name descname">interpolate_to_grid</code><span class="sig-paren">(</span><em class="sig-param">n_voxels</em>, <em class="sig-param">affine</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.interpolate_to_grid" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Interpolates the NodeData into a grid.</dt><dd><p>finds which tetrahedra contais the given voxel and
performs linear interpolation inside the voxel</p>
</dd>
</dl>
<p>The kwargs is ony to have the same interface as the ElementData version</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_voxels</strong> (<em>list</em><em> or </em><em>tuple</em>) – number of voxels in x, y, and z directions</p></li>
<li><p><strong>affine</strong> (<em>ndarray</em>) – A 4x4 matrix specifying the transformation from voxels to xyz</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>image</strong> – An (n_voxels[0], n_voxels[1], n_voxels[2], nr_comp) matrix with
interpolated values. If nr_comp == 1, the last dimension is squeezed out</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.interpolate_to_surface">
<code class="sig-name descname">interpolate_to_surface</code><span class="sig-paren">(</span><em class="sig-param">surface</em>, <em class="sig-param">out_fill='nearest'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.interpolate_to_surface" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates the field in the nodes of a given surface
The interpolation occurs in the tetrahedra!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>surface</strong> (<a class="reference internal" href="simnibs.Msh.html#simnibs.Msh" title="simnibs.Msh"><em>Msh</em></a>) – Mesh structure with triangles only</p></li>
<li><p><strong>out_fill</strong> (<em>float</em><em> or </em><em>'nearest'</em><em> (</em><em>optional</em><em>)</em>) – Value to be assigned to the points in the surface outside the volume.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>node_data</strong> – Node data structure with the interpolated field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.mean_field_norm">
<code class="sig-name descname">mean_field_norm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.mean_field_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates V*w/sum(w)
Where V is the norm of the field, and w is the volume or area of the mesh where
the field is defined. This can be used as a focality metric. It should give out
small values when the field is focal and</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>eff_area</strong> – Area or volume of mesh, weighted by the field</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.node_data2elm_data">
<code class="sig-name descname">node_data2elm_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.node_data2elm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms an ElementData field into a NodeData field
the value in the element is the average of the value in the nodes</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>structure with field value interpolated at element centers</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="simnibs.ElementData.html#simnibs.ElementData" title="simnibs.ElementData">simnibs.ElementData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">node_number</code></dt>
<dd><p>Node numbers (1, …, nr)</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.norm">
<code class="sig-name descname">norm</code><span class="sig-paren">(</span><em class="sig-param">ord=2</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the norm of the field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ord</strong> (<em>float</em>) – Order of norm. Default: 2 (euclidian norm)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>norm</strong> – NodeData field with the norm the field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.normal">
<code class="sig-name descname">normal</code><span class="sig-paren">(</span><em class="sig-param">fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normal component of the field in the mesh surfaces</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface (Default: NaN)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>normal</strong> – NodeData field with the normal the field where a surface is defined and the
fill value where it’s not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">nr</code></dt>
<dd><p>Number of data entries</p>
</dd></dl>

<dl class="method">
<dt>
<em class="property">property </em><code class="sig-name descname">nr_comp</code></dt>
<dd><p>Number of field components</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.read_hdf5_data_matrix_row">
<em class="property">classmethod </em><code class="sig-name descname">read_hdf5_data_matrix_row</code><span class="sig-paren">(</span><em class="sig-param">leadfield_fn</em>, <em class="sig-param">field_name</em>, <em class="sig-param">row</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.read_hdf5_data_matrix_row" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads a row of an hdf5 data matrix and store it as Data</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>leadfield_fn</strong> (<em>str</em>) – Name of file with leadfield</p></li>
<li><p><strong>field_name</strong> (<em>str</em>) – name of field</p></li>
<li><p><strong>row</strong> (<em>int</em>) – number of the row to be read</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>data</strong> – instance with the fields</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Data()</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><em class="sig-param">percentiles=(99.9</em>, <em class="sig-param">99</em>, <em class="sig-param">95)</em>, <em class="sig-param">focality_cutoffs=(75</em>, <em class="sig-param">50)</em>, <em class="sig-param">units=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a text summaty of the field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>percentiles</strong> (<em>ndarray</em><em> (</em><em>optinal</em><em>)</em>) – Field percentiles to be printed. Default: (99.9, 99, 95)</p></li>
<li><p><strong>focality_cutoffs</strong> (<em>ndarray</em><em> (</em><em>optional</em><em>)</em>) – Cuttofs for focality calculations. Default: (75, 50)</p></li>
<li><p><strong>units</strong> (<em>str</em><em> or </em><em>None</em>) – Name of field units or automatically determine from name</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.tangent">
<code class="sig-name descname">tangent</code><span class="sig-paren">(</span><em class="sig-param">fill=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.tangent" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the tangent component of the field in the surfaces</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fill</strong> (<em>float</em><em> (</em><em>optional</em><em>)</em>) – Value to be used when node is not in surface</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>tangent</strong> – NodeData field with the tangent component of the field where a surface is defined and the
fill value where it’s not</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#simnibs.NodeData" title="simnibs.NodeData">NodeData</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.to_deformed_grid">
<code class="sig-name descname">to_deformed_grid</code><span class="sig-paren">(</span><em class="sig-param">warp</em>, <em class="sig-param">reference</em>, <em class="sig-param">out=None</em>, <em class="sig-param">out_original=None</em>, <em class="sig-param">tags=None</em>, <em class="sig-param">order=1</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em>, <em class="sig-param">inverse_warp=None</em>, <em class="sig-param">reference_original=None</em>, <em class="sig-param">binary=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.to_deformed_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates field to a grid and apply non-linear interpolation</p>
<p>We first interpolate to a grid and then apply the transformation in order to
avoid problems from deformed triangles</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>warp</strong> (<em>str</em>) – Name of file with the transformation. Can either be a nifti file
where each voxel corresponds to coordinates (x, y, z) in the original space
or an affine transformation defined from the target space to the original
space. In the later case, the name must finish in “.mat”, and it will be read
with the numpy loadtxt file</p></li>
<li><p><strong>ref</strong> (<em>str</em>) – Name of reference file. The output will be in the same space
as the reference (same affine transfomation and same dimensions)</p></li>
<li><p><strong>out</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the result will be written to this file as a nifti</p></li>
<li><p><strong>out_original</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – If not None, the volume in the original grid be written to this file as a nifti</p></li>
<li><p><strong>tags</strong> (<em>list</em><em> (</em><em>optional</em><em>)</em>) – Mesh tags to be transformed. Defaut: transform the entire mesh</p></li>
<li><p><strong>order</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Interpolation order to be used. Default: 1</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – Method for gridding the data.
If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
<li><p><strong>inverse_warp</strong> (<em>str</em>) – Name of nifti file with inverse the transformation. Used to rotate vectors to the
target space in the case of non-liner transformations. If the transformation is
linear, the inverse matrix is used.</p></li>
<li><p><strong>reference_original</strong> (<em>str</em>) – Name of nifti file with reference in the original space. Used to determine
the dimensions and affine transformation for the initial griding</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>img</strong> – Nibabel image object with tranformed field</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nibabel.Nifti1Pair</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.to_nifti">
<code class="sig-name descname">to_nifti</code><span class="sig-paren">(</span><em class="sig-param">n_voxels</em>, <em class="sig-param">affine</em>, <em class="sig-param">fn=None</em>, <em class="sig-param">units='mm'</em>, <em class="sig-param">qform=None</em>, <em class="sig-param">method='linear'</em>, <em class="sig-param">continuous=False</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.to_nifti" title="Permalink to this definition">¶</a></dt>
<dd><p>Transforms the data in a nifti file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_voxels</strong> (<em>list of ints</em>) – Number of vexels in each dimension</p></li>
<li><p><strong>affine</strong> (<em>4x4 ndarray</em>) – Transformation of voxel space into xyz. This sets the sform</p></li>
<li><p><strong>fn</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – String with file name to be used, if the result is to be saved</p></li>
<li><p><strong>units</strong> (<em>str</em><em> (</em><em>optional</em><em>)</em>) – Units to be set in the NifTI header. Default: mm</p></li>
<li><p><strong>qform</strong> (<em>4x4 ndarray</em><em> (</em><em>optional</em><em>)</em>) – Header qform. Default: set the same as the affine</p></li>
<li><p><strong>method</strong> (<em>{'assign'</em><em> or </em><em>'linear'}</em><em> (</em><em>Optional</em><em>)</em>) – If ‘assign’, gives to each voxel the value of the element that contains
it. If linear, first assign fields to nodes, and then perform
baricentric interpolatiom. Only for ElementData input. Default: linear</p></li>
<li><p><strong>continuous</strong> (<em>bool</em>) – Wether fields is continuous across tissue boundaries. Changes the
behaviour of the function only if method == ‘linear’. Default: False</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>img</strong> – Image object with the field interpolated in the voxels</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>nibabel.Nifti1Pair</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.type">
<em class="property">property </em><code class="sig-name descname">type</code><a class="headerlink" href="#simnibs.NodeData.type" title="Permalink to this definition">¶</a></dt>
<dd><p>NodeData of ElementData</p>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.view_options">
<code class="sig-name descname">view_options</code><span class="sig-paren">(</span><em class="sig-param">v_range='auto'</em>, <em class="sig-param">percentile=False</em>, <em class="sig-param">visible=True</em>, <em class="sig-param">visible_tags=None</em>, <em class="sig-param">saturate=True</em>, <em class="sig-param">idx=None</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.view_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a View object with visualization opions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_range</strong> (<em>[</em><em>min</em><em>, </em><em>max</em><em>] or </em><em>'auto'</em><em> (</em><em>optional</em><em>)</em>) – Range of the values to be displayed. Defaut: will automatically try to find a
good range (0.1 - 99.9% percentile for positive or vector data, symetrical
for two-sided data)</p></li>
<li><p><strong>percentile</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether the values in v_range arre given in percentile (between 0 and 100).
Default: False</p></li>
<li><p><strong>visible</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to turn on visualization of this field. Default: True</p></li>
<li><p><strong>visible_tags</strong> (<em>list</em><em> (</em><em>optional</em><em>)</em>) – List of tags to be visible. Will also be used to calulate field ranges in
‘auto’ mode or if percentile=True. Default: all tags</p></li>
<li><p><strong>saturate</strong> (<em>bool</em><em> (</em><em>optional</em><em>)</em>) – Whether to saturate values. Default: true</p></li>
<li><p><strong>idx</strong> (<em>int</em><em> (</em><em>optional</em><em>)</em>) – Index of this field in the mesh</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>view</strong> – view object</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>gmsh_visualization.View</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.write" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes this NodeData field to a file with field information only
This file needs to be merged with a mesh for visualization</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>fn</strong> (<em>str</em>) – file name</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="simnibs.NodeData.write_hdf5">
<code class="sig-name descname">write_hdf5</code><span class="sig-paren">(</span><em class="sig-param">hdf5_fn</em>, <em class="sig-param">path='./'</em><span class="sig-paren">)</span><a class="headerlink" href="#simnibs.NodeData.write_hdf5" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the field to an hdf5 file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>hdf5_fn</strong> (<em>str</em>) – file name of hdf5 file</p></li>
<li><p><strong>path</strong> (<em>str</em>) – path in the hdf5 file where the field should be saved</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
        <li>
          &larr;
          <a href="simnibs.Elements.html" title="Previous document">simnibs.Elements</a>
        </li>
        <li>
          <a href="simnibs.ElementData.html" title="Next document">simnibs.ElementData</a>
          &rarr;
        </li>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../index.html">
    <img class="logo" src="../../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dataset.html">Example Dataset</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../documentation.html">Documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../gui.html">Graphical User Interface Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../command_line/command_line.html">Command Line Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../sim_struct/sim_struct.html">Simulation Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../opt_struct/opt_struct.html">Optimization Data Structures</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../output_files.html">Output Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../file_formats.html">File Formats in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coordinates.html">Coordinates in SimNIBS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../conductivity.html">Standard Conductivity Values</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../coils.html">Coil Models Included in SimNIBS</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../python_lib.html">Python Library Documentation</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributors.html">Contributors and Funding</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contact.html">Contact</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../documentation.html">Documentation</a><ul>
  <li><a href="../python_lib.html">Python Library Documentation</a><ul>
      <li>Previous: <a href="simnibs.Elements.html" title="previous chapter">simnibs.Elements</a></li>
      <li>Next: <a href="simnibs.ElementData.html" title="next chapter">simnibs.ElementData</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, SimNIBS Developers.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../../_sources/documentation/python_lib/auto/simnibs.NodeData.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>